#!/usr/bin/env python
# coding: utf-8

# # Машинное обучение 1, ПМИ ФКН ВШЭ
# 
# ## Семинар 3 (`numpy`)

# ## NumPy
# 
# **NumPy** — библиотека языка Python, позволяющая (удобно) работать с многомерными массивами и матрицами. Кроме того, NumPy позволяет векторизовать многие вычисления, имеющие место в машинном обучении.
# 
#  - [numpy](http://www.numpy.org)
#  - [numpy tutorial](http://cs231n.github.io/python-numpy-tutorial/)
#  - [100 numpy exercises](http://www.labri.fr/perso/nrougier/teaching/numpy.100/)
#  
# Кстати, про NumPy недавно вышла [публикация](https://www.nature.com/articles/s41586-020-2649-2) в Nature.

# In[1]:


import numpy as np
import warnings
warnings.filterwarnings('ignore')

# Основным типом данных NumPy является многомерный массив элементов одного типа — [numpy.ndarray](http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.array.html). Каждый подобный массив имеет несколько *измерений* или *осей* — в частности, вектор (в классическом понимании) является одномерным массивом и имеет 1 ось, матрица является двумерным массивом и имеет 2 оси и т.д.

# In[2]:


vec = np.array([1, 2, 3])
vec.ndim # количество осей

# In[3]:


mat = np.array([[1, 2, 3], [4, 5, 6]])
mat.ndim

# Чтобы узнать длину массива по каждой из осей, можно воспользоваться атрибутом shape:

# In[4]:


vec.shape

# Чтобы узнать тип элементов и их размер в байтах:

# In[5]:


mat.dtype.name

# In[6]:


mat.itemsize

# #### Создание массивов
# 
# Есть несколько способов сформировать массив в NumPy:
# 
# * Передать итерируемый объект в качестве параметра функции array (можно также явно указать тип элементов):

# In[7]:


A = np.array([1, 2, 3])
A, A.dtype

# In[8]:


A = np.array([1, 2, 3], dtype=float)
A, A.dtype

# * Воспользоваться функциями zeros, ones, empty, identity, если вам нужен объект специального вида:

# In[9]:


np.zeros((3,))

# In[10]:


np.ones((3, 4))

# In[11]:


np.identity(3)

# * Воспользоваться функциями arange (в качестве параметров принимает левую и правую границы последовательности и **шаг**) и linspace (принимает левую и правую границы и **количество элементов**) для формирования последовательностей:

# In[12]:


np.arange(2, 20, 3) # аналогично стандартной функции range python, правая граница не включается

# In[13]:


np.arange(2.5, 8.7, 0.9) # но может работать и с вещественными числами

# In[14]:


np.linspace(2, 18, 14) # правая граница включается (по умолчанию)

# * Изменить размеры существующего массива с помощью reshape (при этом количество элементов должно оставаться неизменным):

# In[15]:


np.arange(9).reshape(3, 3)

# Вместо значения длины массива по одному из измерений можно указать -1 — в этом случае значение будет рассчитано автоматически:

# In[16]:


np.arange(8).reshape(2, -1)

# * Транспонировать существующий массив:

# In[17]:


C = np.arange(6).reshape(2, -1)
C

# In[18]:


C.T

# * Повторить существующий массив:

# In[19]:


a = np.arange(3)
np.tile(a, (2, 2))

# In[20]:


np.tile(a, (4, 1))

# #### Базовые операции
# 
# * Базовые арифметические операции над массивами выполняются поэлементно:

# In[21]:


A = np.arange(9).reshape(3, 3)
B = np.arange(1, 10).reshape(3, 3)

# In[22]:


print(A)
print(B)

# In[23]:


A + B

# In[24]:


A * 1.0 / B

# In[25]:


A + 1

# In[26]:


3 * A

# In[27]:


A ** 2

# Отдельно обратим внимание на то, что умножение массивов также является **поэлементным**, а не матричным:

# In[28]:


A * B

# Для выполнения матричного умножения необходимо использовать функцию dot:

# In[29]:


A.dot(B)

# Для умножения векторов или матриц можно также использовать оператор `@`:

# In[30]:


A @ B

# In[31]:


np.array([1, 2, 3, 4]) @ np.array([1, 1, 1, 1])

# Поскольку операции выполняются поэлементно, операнды бинарных операций должны иметь одинаковый размер. Тем не менее, операция может быть корректно выполнена, если размеры операндов таковы, что они могут быть расширены до одинаковых размеров. Данная возможность называется [broadcasting](http://www.scipy-lectures.org/intro/numpy/operations.html#broadcasting):
# ![](https://jakevdp.github.io/PythonDataScienceHandbook/figures/02.05-broadcasting.png)

# In[32]:


np.tile(np.arange(0, 40, 10), (3, 1)).T + np.array([0, 1, 2])

# * Некоторые операции над массивами (например, вычисления минимума, максимума, суммы элементов) выполняются над всеми элементами вне зависимости от формы массива, однако при указании оси выполняются вдоль нее (например, для нахождения максимума каждой строки или каждого столбца):

# In[33]:


A

# In[34]:


A.min()

# In[35]:


A.max(axis=1)

# In[36]:


A.sum(axis=1)

# #### Индексация
# 
# Для доступа к элементам может использоваться [много различных способов](http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html), рассмотрим основные.
# 
# * Для индексации могут использоваться конкретные значения индексов и срезы (slice), как и в стандартных типах Python. Для многомерных массивов индексы для различных осей разделяются запятой. Если для многомерного массива указаны индексы не для всех измерений, недостающие заполняются полным срезом (:).

# In[37]:


a = np.arange(10)
a

# In[38]:


a[2:5]

# In[39]:


a[3:8:2]

# In[40]:


A = np.arange(81).reshape(9, -1)
A

# In[41]:


A[2:4]

# In[42]:


A[:, 2:4]

# In[43]:


A[2:4, 2:4]

# In[44]:


A[-1]

# * Также может использоваться индексация при помощи списков индексов (по каждой из осей):

# In[45]:


A = np.arange(81).reshape(9, -1)
A

# In[46]:


A[[2, 4, 5], [0, 1, 3]]

# * Может применяться логическая индексация (при помощи логических массивов):

# In[47]:


A = np.arange(11)
A

# In[48]:


A[A % 5 != 3]

# In[49]:


A[np.logical_and(A != 7, A % 5 != 3)] # также можно использовать логические операции

# #### Зачем?
# 
# Зачем необходимо использовать NumPy, если существуют стандартные списки/кортежи и циклы?
# 
# Причина заключается в скорости работы. Попробуем посчитать скалярное произведение 2 больших векторов:

# In[50]:


SIZE = 10000000

A_quick_arr = np.random.normal(size = (SIZE,))
B_quick_arr = np.random.normal(size = (SIZE,))

A_slow_list, B_slow_list = list(A_quick_arr), list(B_quick_arr)

# In[51]:


%%time
ans = 0
for i in range(len(A_slow_list)):
    ans += A_slow_list[i] * B_slow_list[i]

# In[52]:


%%time
ans = sum([A_slow_list[i] * B_slow_list[i] for i in range(SIZE)])

# In[53]:


%%time
ans = np.sum(A_quick_arr * B_quick_arr)

# In[54]:


%%time
ans = A_quick_arr.dot(B_quick_arr)

# NumPy работает быстро по нескольким причинам:
# * Массивы хранятся в непрерывном участке памяти, а все элементы имеют один и тот же тип
# * Для вычислений по возможности используются библиотеки линейной алгебры вроде BLAS
# 
# Посмотреть, какая библиотека используется у вас, можно в конфигурации NumPy:

# In[55]:


print(np.show_config())

# ### Примеры векторизации вычислений на NumPy
# 

# Разберём несколько задач (из [100 numpy exercises](http://www.labri.fr/perso/nrougier/teaching/numpy.100/)), где NumPy может существенно ускорить вычисления и упростить код.

# Дан четырёхмерный массив. Как получить двумерный массив, в котором элемент с индексами $(i, j)$ содержит сумму всех элементов исходного массива, у которых первые два индекса — это $(i, j)$?

# In[56]:


A = np.random.randint(0,1000,(2,5,20,25))
res = A.reshape(A.shape[:-2] + (-1,)).sum(axis=-1)
print(res)

# Даны одномерные массивы A и B. Элементы массива B принимают значения от 0 до `len(A) - 1`. Требуется прибавить единицу ко всем элементам A, чьи индексы записаны в B. Если индекс встречается в B несколько раз, то надо прибавить единицу для каждого такого вхождения.

# In[57]:


A = np.ones(10)
B = np.random.randint(0,len(A),20)
print(A)
print(B)
A += np.bincount(B, minlength=len(A))
print(A)

# Даны одномерный массив A и число n. Вычислите массив B, в котором i-й элемент равен среднему значению элементов с i-го по (i+n-1)-й в массиве A.

# In[58]:


def moving_average(Z, n=3) :
    ret = np.cumsum(Z, dtype=float)
    ret[n:] = ret[n:] - ret[:-n]
    return ret[n - 1:] / n
A = np.random.randint(0, 10, 20)
print(A)
print(moving_average(A, n=3))
