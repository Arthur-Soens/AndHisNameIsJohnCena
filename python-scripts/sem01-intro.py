#!/usr/bin/env python
# coding: utf-8

#  # <center> Машинное обучение, ФКН ВШЭ. Семинар 1 </center>
# 
# <img src="https://www.dropbox.com/s/ky2i6e9yix3avq2/walli.jpg?raw=1" style="width: 800px;"></img>
# 
# На этом семинаре:
# 
# * Познакомимся с задачами машинного обучения.
# * Разберем основные инструменты для работы с данными.

# ## Что мы будем изучать?
# 
# Вдохновляющий видос: https://youtu.be/l95h4alXfAA
# 
# **Машинное обучение** — это раздел математики, изучающий способы извлечения закономерностей из ограниченного числа примеров.

# ### Примеры задач машинного обучения
# 
# Рассмотрим несколько примеров задач, которые решаются с помощью машинного обучения.
# 
# ##### - Кредитный скоринг
# 
#     Задача: выяснить, какие заявки на кредит можно одобрить.
# 
# <img src="https://www.dropbox.com/s/vc08m9lmkokrzi4/credit.jpg?raw=1" style="width: 600px;">
#    
# ##### - Лента Facebook/Дзен по интересности (вместо сортировки по времени)
#      
#      Задача: показать посты, наиболее интересные для конкретного человека.
# 
# <img src="https://www.dropbox.com/s/1oclybrw3gwbnpo/dzen.png?raw=1" style="width: 800px;">  
# 
# ##### - Детектирование некорректной работы 
# 
#      Предположим, что у нас есть завод, на котором происходят некоторые процессы (стоят какие-то котлы, станки, работают сотрудники). На предприятии может произойти поломка, например, сломается датчик уровня жидкости в баке, из-за чего насос не остановится при достижении нужного уровня и нефть начнёт разливаться по полу, что может привести к неизвестным последствиям. Или же сотрудники объявят забастовку и вся работа остановится. Мы хотим, чтобы завод работал исправно, а обо всех проблемах узнавать как можно раньше.
#      Задача: предсказать поломки/нештатные ситуации на заводе.
# 
# <img src="https://www.dropbox.com/s/gy7em5may9tmuug/minions.jpeg?raw=1" style="width: 600px;"> 
# 
# 
# ##### - Вопросно-ответная система (как Siri)
#     
#     Задача: ответить голосом на вопрос, заданный голосом.
# <img src="https://www.dropbox.com/s/vifhcpz5k3douh1/alice.jpg?raw=1" style="width: 800px;"> 
# 
# 
# ##### - Self-driving cars
#      
#     Задача: доехать из точки А в точку В.
# 
# <img src="https://www.dropbox.com/s/jdf0ofgpqp29toz/self-drive.jpg?raw=1" style="width: 750px;"> 
# 
# 
# ##### - Перенос стиля изображения
#    
#     Задача: перенести стиль одного изображения на другое (смешать стиль одного с контекстом другого).
#      
# <img src="https://www.dropbox.com/s/1nclrj2po5qui0y/style.jpeg?raw=1" style="width: 950px;"> 

# Как видим, задачи очень разнообразны. Мы начнем наш путь со следующей классической постановки (к которой, кстати, сводятся многие вышеперечисленные задачи): по имеющемуся признаковому описанию объекта $x \in \mathbb{R}^m$ предсказать значение целевой переменной $y \in \mathbb{R}^k$ для данного объекта. Обычно $k=1$.
# 
# Например, в случае кредитного скоринга $x$-ом являются все известные о клиенте данные (доход, пол, возраст, кредитная история и т.д.), а $y$-ом одобрение или неодобрение заявки на кредит.

# ### Наши инструменты
# 
# #### Python
# 
# У всех датасайентистов свои привычки и вкусы. Часто требования к используемым инструментам выставляются на работе, особенно если она происходит в команде с другими аналитиками и разработчиками. Чаще всего (по опросам на 2018 год) аналитики данных используют язык программирования Python (его мы и будем использовать в этом курсе) по нескольким причинам:
#    
# - Популярность языка в целом (в первой тройке по различным критериям на Github и в десятке самых популярных по различным точкам зрения других рейтингов) — много разработчиков, много различных инструментов.
# - Простота изучения — многие аналитики данных не являются программистами как таковыми, а при обучении стремятся как можно быстрее изучить необходимый им инструмент. 
# - Простота использования. Python — интерпретируемый язык (не требует компиляции кода) с динамической типизацией и многими прочими особенностями, позволяющими как можно меньше думать о программировании и больше концентрироваться на решении конкретной задачи.
#    
# Нельзя сказать, что можно обойтись на практике одним лишь языком Python. Большинство реальных систем предъявляет требования к скорости работы, а Python в этом обычно уступает классическим компилируемым языкам вроде C++ или Java, поэтому на практике часто подготовленные на Python решения переписываются или встраиваются с минимальными потерями в другие языки.
# 
# Кроме Python, аналитики данных часто используют язык R, который так же достаточно прост и удобен, однако почти не используется в кругах разработчиков. Реже и в некоторых специфичных задачах применяются Matlab и SAS.
# 
# #### Библиотеки
# 
# Но одним лишь языком программирования не обойтись — используются различные инструменты и библиотеки (мы рассматриваем лишь Python):
#    
# - Среда разработки.  На семинарах и в домашках мы будем использовать [Jupyter Notebook](https://jupyter.org). Он позволяет как писать код и запускать его отдельными фрагментами, так и оформлять всё в виде отчёта с markdown разметкой и формулами LaTex. И даже [вставлять видосы с YouTube](https://gist.github.com/christopherlovell/e3e70880c0b0ad666e7b5fe311320a62)! 
# - Библиотеки для обработки данных: [NumPy](https://numpy.org) и [Pandas](https://pandas.pydata.org).
# - Библиотеки для визуализации данных: [Matplotlib](https://matplotlib.org) и [Seaborn](https://seaborn.pydata.org/#).
# - Библиотеки с алгоритмами машинного обучения: [scikit-learn](http://scikit-learn.github.io/stable), [XGBoost](https://xgboost.readthedocs.io/en/latest/) и [pytorch](https://pytorch.org).

# ### Работа с данными (Pandas)
# <img src="https://www.dropbox.com/s/qeh64d6jsynffo7/pandas.gif?raw=1">
# 
# Аналитикам часто приходится работать с табличными данными. В Python это удобно делать с помощью библиотеки Pandas, давайте с ней познакомимся.

# In[38]:


import pandas as pd

# Сегодня мы с вами будем работать с [корпусом русскоязычных твитов](http://study.mokoron.com)
# 
# Корпус состоит из 12 столбцов:
# 
#     – id: уникальный номер сообщения в системе twitter;
#     – tdate: дата публикации сообщения (твита);
#     – tmane: имя пользователя, опубликовавшего сообщение;
#     – ttext:  текст сообщения (твита);
#     – ttype: поле в котором в дальнейшем будет указано к кому классу относится твит (положительный, отрицательный, нейтральный);
#     – trep: количество реплаев к данному сообщению. В настоящий момент API твиттера не отдает эту информацию;
#     – tfav: число сколько раз данное сообщение было добавлено в избранное другими пользователями;
#     – tstcount: число всех сообщений пользователя в сети twitter;
#     – tfol: количество фолловеров пользователя (тех людей, которые читают пользователя);
#     – tfrien: количество друзей пользователя (те люди, которых читает пользователь);
#     – listcount: количество листов-подписок в которые добавлен твиттер-пользователь.

# Загрузим данные:

# In[39]:


! wget  -O 'tweets.csv' -q 'https://www.dropbox.com/s/ou55qwyhbj1pdav/tweets.csv?dl=1'

# In[40]:


import pandas as pd
data = pd.read_csv("tweets.csv")

# In[41]:


data = pd.read_csv("tweets.csv")

# In[42]:


data

# Теперь данные хранятся в переменной ```data```, которая имеет тип [DataFrame](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html):

# In[43]:


type(data)

# DataFrame можно частично отобразить в jupyter-ноутбуке с помощью методов ```sample``` и ```head```:

# In[44]:


data.head(6)

# In[45]:


data.sample(6)

# Можно отобразить и весь датасет, но это обычно слишком громоздко:

# In[46]:


data

# DataFrame по сути является двумерной табличкой с набором полезных методов. Давайте рассмотрим основные из них.

# В DataFrame есть несколько методов для обращения к строкам, столбцам и отдельным элементам таблицы: методы ```loc```, ```iloc``` и через квадратные скобки. Давайте поймем, в чем между ними разница, на примерах.
# 
# В метод ```loc``` можно передать значение индекса (число, которое стоит в колонке index) строки, чтобы получить эту строку:

# In[53]:


data.loc[2]

# Получили отдельную строчку в виде объекта класса [Series](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html):

# In[54]:


type(data.loc[2])

# А с помощью срезов можно выбрать часть таблицы:

# In[55]:


data.loc[2:4]

# Срез в ```loc``` производится по index и включает в себя последний элемент.
# 
# Метод ```iloc``` действует похожим образом, но он индексирует элементы не по index, а по порядку в таблице (который может отличаться от index). Например:

# In[56]:


subset = data.sample(5)
subset

# In[57]:


subset.iloc[2]

# In[58]:


subset.loc[2]

# С помощью ```iloc``` тоже можно делать срезы, но в них последний элемент не включается (как и в обычных срезах в Python):

# In[59]:


data.iloc[2:4]

# Срезы можно брать не только по строкам, но и по столбцам. Обратите внимание на различия индексации столбцов в ```loc``` и ```iloc```:

# In[60]:


data.iloc[2:4,0:3]

# In[61]:


data.loc[2:4, 'id':'tmane']

# Через квадратные скобки можно обращаться к одной или нескольким колонкам:

# In[62]:


data['tdate'].head()

# In[63]:


data[['tdate', 'tmane']].head()

# Есть и более интересные способы индексации. Например, давайте выберем твиты, у которых число лайков больше нуля:

# In[64]:


data[data.tfav > 0].head()

# С DataFrame'ами и Series'ами одинаковой структуры можно производить математические операции:

# In[65]:


strange_feature = data.tfav ** 2 * data.trep + data.tfrien - data.listcount
strange_feature.head()

# Можно добавлять новые колонки:

# In[66]:


data['new'] = strange_feature
data.head()

# И удалять их:

# In[67]:


data = data.drop(columns=['new'])
data.head()

# ### Разведочный анализ
# 
# Мы немного познакомились с функциональностью Pandas, давайте теперь поизучаем данные. Предположим, мы перед нами стоит задача по имеющимся числовым признакам предсказать, является твит позитивным или негативным. Давайте посмотрим, какие закономерности мы можем извлечь из данных без использования алгоритмов машинного обучения.

# Для начала, выделим какие-нибудь полезные признаки из текстов твитов. Например, наличие позитивного и негативного смайлика.

# In[28]:


data['has_neg'] = data.apply(lambda x: '(' in x['ttext'], axis=1).astype('int')
data['has_pos'] = data.apply(lambda x: ')' in x['ttext'], axis=1).astype('int')

# In[29]:


data.head()

# Посчитаем количество твитов каждого типа (позитивные и негативные):

# In[30]:


data.ttype.value_counts()

# У нас примерно одинаковое количество позитивных и негативных твитов, т.е. выборка сбалансирована.
# 
# Посмотрим на основные статистики по числовым признакам:

# In[31]:


data.describe()

# Что можно сказать о распределении каждого из признаков (симметричность, наличие выбросов, длинных хвостов)?
# 
# Сравним статистики для позитивных и негативных твитов:

# In[32]:


data[data.ttype == -1].describe()

# In[33]:


data[data.ttype == 1].describe()

# * Значения статистик каких признаков сильно отличаются для позитивных и негативных твитов? Как это можно объяснить?
# * Какие признаки могут быть полезны для предсказания тональности твита? Почему?

# Посмотрим, насколько признаки скоррелированны друг с другом:

# In[34]:


import matplotlib.pyplot as plt
import seaborn as sns

# In[36]:


corrmat = data.corr()
corrmat

# Получили матрицу корреляций, посмотрим на нее в виде heatmap:

# In[28]:


plt.figure(figsize=(8, 8))
sns.heatmap(corrmat, square=True)
plt.show()

# Какие признаки сильно скоррелированы? Как это можно объяснить?

# Посмотрим на еще одну визуализацию: [seaborn.pairplot](https://seaborn.pydata.org/generated/seaborn.pairplot.html).
# 
# Эта функция выдает матрицу из графиков: по диагонали стоят гистограммы значений каждого признака, а в остальных ячейках &mdash; графики значений каждого признака против каждого. Кроме того, точки на графиках можно раскрасить в разные цвета по какому-либо категориальному признаку с помощью аргумента ```hue```. Это позволяет сравнить, какие значения принимает признак в зависимости от категории. Давайте раскрасим наши графики по ```ttype```, чтобы сравнить распределения признаков для позитивных и негативных твитов.

# In[35]:


sns.set()
cols = ['id', 'tdate', 'tfav', 'tstcount', 'tfol', 'tfrien', 'listcount', 'ttype', 'has_neg', 'has_pos']
sns.pairplot(data[cols], hue='ttype')

# Давайте посмотрим на графики и ответим на вопросы:
# * Между какими признаками видна зависимость? Как ее можно объяснить?
# * Какие признаки будут полезны для предсказания типа твита, а какие, скорее всего, бесполезны? Почему?
# 
# Построим отдельно самые интересные зависимости:

# In[34]:


sns.set()
cols = ['id','tdate', 'ttype', 'has_neg', 'has_pos']
sns.pairplot(data[cols], hue='ttype')
