#!/usr/bin/env python
# coding: utf-8

# # Машинное обучение, ФКН ВШЭ
# 
# ## Практическое задание 1
# 
# ### Общая информация
# Дата выдачи: 18.09.2017  
# 
# Мягкий дедлайн: 23:59MSK 01.10.2017 (за каждый день просрочки снимается 1 балл)
# 
# Жесткий дедлайн: 23:59MSK 08.10.2017  

# ### О задании
# 
# __Первая часть__ задания посвящена получению студентами навыков работы с библиотекой векторного вычисления numpy и библиотеками для построения графиков matplotlib/plotly. Это задание сдается частично в Яндекс.Контест (см. информацию ниже). В случае проблем с доступом к Яндекс.Контесту обращайтесь к своему семинаристу(ке).
# 
# __Вторая часть__ задания посвящена работе с данными: их преобразованию в нужный формат и устранению проблем в них.
# 
# 
# ### Оценивание и штрафы
# Каждая из задач имеет определенную «стоимость» (указана в скобках около задачи). Максимально допустимая оценка за работу — 10 баллов.
# 
# Сдавать задание после указанного срока сдачи нельзя. При выставлении неполного балла за задание в связи с наличием ошибок на усмотрение проверяющего предусмотрена возможность исправить работу на указанных в ответном письме условиях.
# 
# Задание выполняется самостоятельно. «Похожие» решения считаются плагиатом и все задействованные студенты (в том числе те, у кого списали) не могут получить за него больше 0 баллов (подробнее о плагиате см. на странице курса). Если вы нашли решение какого-то из заданий (или его часть) в открытом источнике, необходимо указать ссылку на этот источник в отдельном блоке в конце Вашей работы (скорее всего вы будете не единственным, кто это нашел, поэтому чтобы исключить подозрение в плагиате, необходима ссылка на источник).
# 
# Неэффективная реализация кода может негативно отразиться на оценке.
# 
# 
# ### Формат сдачи
# Для сдачи задания переименуйте получившийся файл *.ipynb в соответствии со следующим форматом: homework-practice-01-Username.ipynb, где Username — Ваша фамилия и имя на латинице именно в таком порядке (например, homework-practice-01-IvanovIvan.ipynb). Приложите модули с кодом functions.py и functions_vectorized.py и заархивируйте в zip формат. Имя архива должно быть homework-practice-01-Username.zip
# 
# Далее отправьте этот файл на hse.cs.ml+<номер группы>@gmail.com (например, hse.cs.ml+141@gmail.com для студентов группы БПМИ-141).
# 
# 
# Для удобства проверки самостоятельно посчитайте свою максимальную оценку (исходя из набора решенных задач) и укажите ниже.

# **Оценка:** ...

# ## Часть 1
# 
# _Задачи позаимствованы из курса практикума кафедры ММП факультета ВМК МГУ_

# ### Задачи 1-6
# __(4.5 балла)__
# 
# Ниже приведены задачи на работу с numpy-массивами. Для каждой из задач нужно привести 2 реализации: одна без использования numpy (cчитайте, что там, где на входе или выходе должны быть numpy array, будут просто списки), а вторая полностью векторизованная (без использования питоновских циклов/map/list comprehension). Невекторизованная реализация каждой из задач оценивается в __0.25 балла__, векторизованная – в __0.5 балла__.
# 
# Реализации без использования векторизации нужно записать в файл functions.py, а векторизованные &mdash; в файл functions_vectorized.py (см. шаблоны). Далее эти файлы необходимо сдать в Яндекс.Контест: https://official.contest.yandex.ru/contest/5016/problems/ в соответствующие задачи. По техническим причинам тестирование проводится на этапе компиляции, поэтому в случае любой ошибки вы будете получать вердикт CE, и в логе компиляции можно будет посмотреть, в чем проблема. Частичное выполнение задания (не все задачи) будет оцениваться, хотя и будет получать вердикт CE. Для удобства проверки приложите в ячейке ниже ссылки на самые успешные посылки.
# 
# 
# * __Задача 1__: Подсчитать произведение ненулевых элементов на диагонали прямоугольной матрицы.  
#  Например, для X = np.array([[1, 0, 1], [2, 0, 2], [3, 0, 3], [4, 4, 4]]) ответ – 3.
#  
#  
# * __Задача 2__: Даны два вектора x и y. Проверить, задают ли они одно и то же мультимножество.  
#   Например, для x = np.array([1, 2, 2, 4]), y = np.array([4, 2, 1, 2]) ответ – True.
#   
#   
# * __Задача 3__: Найти максимальный элемент в векторе x среди элементов, перед которыми стоит нулевой.  
#  Например, для x = np.array([6, 2, 0, 3, 0, 0, 5, 7, 0]) ответ – 5.
#  
#  
# * __ Задача 4__: Дан трёхмерный массив, содержащий изображение, размера (height, width, numChannels), а также вектор длины numChannels. Сложить каналы изображения с указанными весами, и вернуть результат в виде матрицы размера (height, width). В ноутбуке приведите пример работы функции – преобразуйте цветное изображение в оттенки серого, использовав коэффициенты np.array([0.299, 0.587, 0.114]). Считать реальное изображение можно при помощи функции scipy.misc.imread (если изображение не в формате png, установите пакет pillow).
# 
# 
# * __Задача 5__: Реализовать кодирование длин серий (Run-length encoding). Для некоторого вектора x необходимо вернуть кортеж из двух векторов одинаковой длины. Первый содержит числа, а второй - сколько раз их нужно повторить.  
#  Например, для x = np.array([2, 2, 2, 3, 3, 3, 5]) ответ – (np.array([2, 3, 5]), np.array([3, 3, 1])).
#  
#  
# * __Задача 6__: Даны две выборки объектов - X и Y. Вычислить матрицу евклидовых расстояний между объектами. Сравните с функцией scipy.spatial.distance.cdist по скорости работы (сравнения приведите ниже в ноутбуке).
# 
# __Замечание.__ Можно считать, что все указанные объекты непустые (к примеру, в __задаче 1__ на диагонали матрицы есть ненулевые элементы) и корректные.

# Посылка по невекторизованным функциям: ...
# 
# Посылка по векторизованным функциям: ...

# ### Задача 7
# __(1.5 балла)__  
# Для каждой задачи сравните скорость работы невекторизованной и векторизованной реализации. С помощью пакета matplotlib или plotly постройте графики времени работы в зависимости от размера данных. __Графики должны выглядеть опрятно!__ То есть должны быть подписаны оси, названия графиков, и т.д. Например, ниже представлены хороший и плохой графики:

# In[1]:


import matplotlib.pyplot as plt
import numpy as np


data_size = np.array([10, 30, 70, 120])
time_non_vectorized = data_size ** 2 + 10
time_vectorized = data_size ** 1.5

f, (ax1, ax2) = plt.subplots(1, 2, figsize=(13, 5))

ax1.plot(data_size, time_non_vectorized)
ax1.plot(data_size, time_vectorized)
ax1.set_title(u"Плохой график")
ax1.set_xlabel(u"Размер данных")
ax1.set_ylabel(u"Время")

ax2.plot(data_size, time_non_vectorized, label=u"Невекторизованная")
ax2.plot(data_size, time_vectorized, label=u"Векторизованная")
ax2.set_title(u"Хороший график")
ax2.set_xlabel(u"Длина массива")
ax2.set_ylabel(u"Время (с)")
ax2.grid()
ax2.legend()

f.show()              

# In[ ]:


# Your code here
# ...

# ## Часть 2
# 
# В данном задании мы рассмотрим набор данных об учащихся, собранный в 2006 году в одной из школ Португалии. Данные представлены в неудобном для машинного обучения виде, и содержат мусор. Ваша задача &mdash; привести их к надлежащему виду и обучить на них простую модель.
# 
# **Внимание!** Хотя исходные данные для этого задания можно найти в интернете, делать это запрещается. Вся необходимая информация о данных содержится в задании. В случае затруднений обращайтесь к своему семинаристу(ке).
# 
# Данные состоят из четырех файлов:
# - data.csv &mdash; основная таблица с информацией о учащихся
# - scores.csv &mdash; список финальных оценок по одному из предметов (20-балльная шкала переведенная в проценты)
# - attendance.csv &mdash; таблица посещений занятий по этому предмету
# - school_support.txt &mdash; список учащихся, которым оказывается финансовая поддержка
# 
# Ваша задача &mdash; построить модель для предсказания финальных оценок исходя из всех остальных данных. В качестве алгоритма мы будем использовать линейную регрессию, ак ачество будем измерять по метрике RMSE.
# 
# Расшифровка столбцов в data.csv для справки:
# - age &mdash; возраст
# - Medu &mdash; уровень образования матери (по некоторой условной шкале)
# - Fedu &mdash; уровень образования отца (по некоторой условной шкале)
# - traveltime &mdash; время в пути до школы (1 – < 15 мин., 2 – от 15 до 30 мин., 3 – от 30 мин. to 1 ч.
# или 4 – > 1 ч.)
# - studytime &mdash; время, затрачиваемое на занятия вне школы (1 – < 2 ч., 2 – от 2 до 5 ч., 3 – от 5 до 10 ч. или 4 – > 10 ч.)
# - famrel &mdash; насколько хорошие отношения в семье у учащегося (по некоторой условной шкале)
# - freetime &mdash; количество свободного времени вне школы (по некоторой условной шкале)
# - goout &mdash; время, затрачиваемое на общение с друзьями (по некоторой условной шкале)
# - Dalc &mdash; количество употребления алкоголя в учебные дни (по некоторой условной шкале)
# - Walc &mdash; количество употребления алкоголя в неучебные дни (по некоторой условной шкале)
# - health &mdash; уровень здоровья (по некоторой условной шкале)
# - sex_M &mdash; пол: мужской (1) или женский (0)
# - address_U &mdash; живет ли учащийся в городе (1) или в пригороде (0)
# - famsize_LE3 &mdash; размер семьи: не больше 3 человек (1) или больше (0)
# - Pstatus_T &mdash; живут ли родители вместе (1) или отдельно (0)
# - nursery &mdash; посещал ли учащийся детский сад
# - plans_university &mdash; планирует ли учащийся поступать в университет (-1 или 1)
# - past_failures &mdash; количество неудовлетворительных оценок по другим предметам ранее (от 0 до 4)

# ### Задача 1: пропуски в данных 
# __(0.5 балла)__
# 
# Загрузите таблицу data.csv. Проверьте, есть ли в ней пропуски (значения NaN). Замените все пропущенные значения на среднее значение этого признака по столбцу.
# 
# *Hint: изучите в pandas функции loc, isnull, а также передачу булевых массивов в качестве индексов.*

# In[ ]:


# Your code here
# ...

# ### Задача 2: кросс-валидация для исходных данных
# __(0.5 балла)__
# 
# Загрузите файл scores.csv и протестируйте, как линейная регрессия предсказывает ответ сейчас (с помощью кросс-валидации).
# 
# *Hint: воспользуйтесь sklearn.linear_model и sklearn.model_selection.*

# In[ ]:


# Your code here
# ...

# ### Задача 3: полные данные
# __(1 балл)__
# 
# Воспользуйтесь файлами attendance.csv и school_support.txt для того, чтобы добавить новые признаки в данные. Желательно по максимуму использовать возможности pandas для упрощения преобразований.

# In[ ]:


# Your code here
# ...

# ### Задача 4: сломанный признак
# __(0.5 балла)__
# 
# Найдите в данных сломанный признак (он не соответствует описанию) и исправьте его.

# In[ ]:


# Your code here
# ...

# ### Задача 5: борьба с выбросами
# __(1.5 балла)__
# 
# Качество предсказания может ухудшаться, если в данных присутствуют корректные значения признаков (с точки зрения чтения данных и применения методов), но не соответствующие реальным объектам. Например, данные могли быть введены в неверном формате, а потом слишком грубо приведены к общему виду, из-за чего ошибка не была замечена.
# Попробуем от такого избавиться &mdash; а для этого такие объекты нужно сначала найти. Конечно, нам еще недоступны многие продвинутые способы, но давайте попробуем обойтись простыми.
# 
# Первый способ это сделать &mdash; посмотреть для каждого признака на распределение его значений и проверить крайние значения на правдоподобность.
# 
# *Hint 1: используйте функцию DataFrame.hist*
# 
# *Hint 2: в описании датасета выше есть информация, необходимая для восстановления правильных значений*

# In[ ]:


# Your code here
# ...

# Другой простой способ найти выбросы &mdash; сделать предсказание на всех объектах и посмотреть на объекты с наибольшей ошибкой. Обратите внимание, что просто удалять все объекты с высокой ошибкой нельзя &mdash; это, конечно, хороший способ добиться меньшей ошибки (на данной выборке), но одновременно вы ухудшите обобщающую способность алгоритма. Вместо этого вам нужно найти однозначно ошибочные записи и их исправить.
# 
# *Hint: возможно, все проблемы уже были найдены в прошлом пункте; для проверки &mdash; в обоих пунктах в сумме нужно исправить 3 проблемы.*

# In[ ]:


# Your code here
# ...

# ### Финальное предсказание
# 
# Проведите предсказание еще раз и сравните результат с исходным.

# In[ ]:


# Your code here
# ...
